<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_75) on Wed Jul 22 19:46:54 PDT 2015 -->
<title>Overview (Protocols Codec SDK 2.1.2.2.RELEASE API)</title>
<meta name="date" content="2015-07-22">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (Protocols Codec SDK 2.1.2.2.RELEASE API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-files/index-1.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">Protocols Codec SDK 2.1.2.2.RELEASE API</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">This document is the API specification for RTI Protocol Codec SDK
<hr/></div>
</div>
<p>See: <a href="#overview_description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="io/pivotal/rti/protocols/package-summary.html">io.pivotal.rti.protocols</a></td>
<td class="colLast">
<div class="block">protocols-sdk API package.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="io/pivotal/rti/prtocols/adapter/test/harness/package-summary.html">io.pivotal.rti.prtocols.adapter.test.harness</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="footer"><a name="overview_description">
<!--   -->
</a>
<div class="subTitle">
<div class="block">This document is the API specification for RTI Protocol Codec SDK
<hr/>

    <p>
        <h1>Overview and Basic Protocol Adapter Implementation</h1>
        Protocols Codec SDK is an API that provides a programming interface for external protocol codec
        contributions those are not part of native RTI. This document gives an overview on the steps that
        a programmer must take to provide non-native RTI Protocol implementations.

    <p>
        The main artifact that the partner codec implementations need to use for developing external codecs is protocols-api.
        This is the only mandatory dependency for external codec implementations. There are other optional modules available
        through the SDK and their usage can be found in the later sections of this document.

    <p>
        The core class that must be extended for implementing a new protocol adapter is <code>AbstractProtocolAdapter</code>.
        Implementations must override the abstract method <code>AbstractProtocolAdapter#bytesToProtocolEvent</code>.
        This method takes a source byte array and transforms them into one or more <code>ProtocolEvent</code>s.
        The external implementer has the complete control over how the logic for this codec transformation is laid out.
        This method returns a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html">Collection</a>
        of <code>ProtocolEvent</code>s.
    <p>
        In addition to implementing the above method, you should also call the abstract parent's constructor
        from the implementation constructor and passing in the protocol name.
    </p>

    <p>
        Here is a potential ProtocolAdapter implementation based on a contrived protocol FooBar for illustration purposes.
    </p>

<pre class="code">
package foo.bar;

public class FooBarProtocolAdapter extends AbstractProtocolAdapter {

    public FooBarProtocolAdapter() {
        super("foobar");
    }

    &#064;Override
    public List&lt;ProtocolEvent&gt; bytesToProtocolEvent(byte[] b) throws IOException {
        //Implement your logic here
    }
}
</pre>
    <p>
        Although the implementations must start from extending <code>AbstractProtocolAdapter</code>, the
        fundamental contract for protocol adapters is provided through <code>ProtocolAdapter</code>
        which is an interface that <code>AbstractProtocolAdapter</code> implements. This is the interface
        used by various downstream systems in RTI to detect the presence of partner codec implementations. It is recommended and
        encouraged for the implementers <b>not</b> to directly implement this interface. The reason is that, extending the
        <code>AbstractProtocolAdapter</code> gives other benefits such as JMX management,
        error handling etc. automatically. If the <code>ProtocolAdapter</code> is implemented
        directly then it would be the responsibility of the author to provide such JMX support by also implementing methods
        in <code>ProtocolMetricManager</code>. In order to reduce this complexity, it is not recommended
        the implementers directly implement the interface, rather extend the provided abstract implementation.

    <p>
    <h1>Registering the Protocol Adapter with RTI</h1>
        Once you have the implementation ready, there are two ways by which you can register the new <code>ProtocolAdapter</code>
        into the RTI deployment which are outlined below.
<ol>
<li>
            Provide a <a href="http://projects.spring.io/spring-framework/">Spring Framework</a> based <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html">
            Configuration</a> class that is intended for auto configuring your ProtocolAdapter. Here is an example of a minimal such
            auto-configuration class based on the protocol adapter used as an example above:
            <pre class="code">
package foo.bar.autoconfig;
&#064;Configuration
public class FooBarProtocolAdapterAutoConfiguration {
    &#064;Bean
    public FooBarProtocolAdapter foobarProtocolAdapter() {
        return new FooBarProtocolAdapter();
    }
}
            </pre>
<p>
    Then you need to create a properties file, named as protocol.adapter inside the META-INF directory. This file must contain a key/value pair
    in the form protocolName=&lt;Fully qualified class name of the autoconfiguration class&gt;.
    For example based on the above example, here is a sample protocol.adapter file.
    <pre class="code">
foobar=foo.bar.autoconfig.FooProtocolAdapterAutoConfiguration
        </pre>
    <p>
        <b>Please note that the property key above must match with the protocol name defined in your implementation class.</b>
    </p>

    If you are following this approach, make sure that you have the proper Spring dependencies added to your project. The SDK provides
    a convenient protocol-api-config-dependencies module that specifies the compatible Spring versions that you need to use
    alongside your implementation. If you don't want to include Spring dependencies notwithstanding its advantages (as we will see
    shortly) and just want to provide a standard adapter implementation please look at option 2 below.

        </li>
    <p>
    <li>
        The other way to register the protocol adapter is more straight forward and does not require you to have any Spring dependencies.
        You simply create a ProtocolAdapter implementation as above and provide the protocol.adapter file in META-INF as following and that is
        all required unless you have constructor parameters. Here is a sample protocol.adapter file in this case.
    <pre class="code">
foobar=foo.bar.FooProtocolAdapter
        </pre>
    <p>
    If the ProtocolAdapter implementation has constructor parameters, then you must tag your constructor with
    <code>ConstructorArgumentKeys</code> annotation and provide keys that correspond to the parameters in the declaration order. For example,
    if your FooBarProtocolAdapter constructor takes three parameters, your implementation would change something along the following lines.

    <pre class="code">
package foo.bar;

public class FooBarProtocolAdapter extends AbstractProtocolAdapter {

    String version;
    int size;
    boolean foobarAllowed;

    &#064;ConstructorArgumentKeys(keys={"foobar.version","foobar.size","foobar.foobarAllowed"})
    public FooBarProtocolAdapter(String version, int size, boolean foobarAllowed;) {
        super("foobar");
        this.version = version;
        this.size = size;
        this.foobarAllowed = foobarAllowed;
    }

    &#064;Override
    public List&lt;ProtocolEvent&gt; bytesToProtocolEvent(byte[] b) throws IOException {
        //Implement your logic here
    }
}
</pre>
    <p>Then you need to have a standard properties file with the key/value pairs for these parameters. The property file
    must be named as protocolName.properties. For example, based on our running example, you would need to define
    a file called foobar.properties at the root of your classpath. Following is an example of such a file.</p>

    <pre class="code">
foobar.version=x.y.z
foobar.size=1
foobar.foobarAllowed=true
        </pre>
<p></p>
    Please note that you can only have a single constructor with this approach.
    <p>
        If we take this same example with constructor arguments and decide to use against a Spring auto configuration,
        then
        you don&apos;t have to worry about providing the <code>ConstructorArgumentKeys</code>. You can then
        use standard Spring mechanisms to wire the arguments. Here is an example.
        <p>
        <pre class="code">
package foo.bar.autoconfig;
&#064;Configuration
public class FooBarProtocolAdapterAutoConfiguration {

    &#064;Value("${foobar.version:x.y.z}")
    String version;

    &#064;Value("${foobar.size:1}")
    int size;

    &#064;Value("${foobar.foobarAllowed:false}")
    boolean foobarAllowed;

    &#064;Bean
    public FooBarProtocolAdapter foobarProtocolAdapter() {
        return new FooBarProtocolAdapter(version, size, foobarAllowed);
    }
}
            </pre>
    <p>
        Note that with this approach, defaults can be provided and still be overridden from external properties file. For example, you still
        can provide a foobar.properties file at your classpath root and provide the overridden values.
        <p>
        <pre class="code">
foobar.version=x.y.z-1
foobar.size=10
foobar.foobarAllowed=true
        </pre>
<p>
    With this Spring approach, there is no restriction in the number of constructors in your implementation as you are in control
    of instantiating the class for RTI and thus pick whichever constructor works for your needs.
</p>
    </li>
</ol>

<p>
<h1>Overriding default TCP server in RTI Ingester</h1>
    By default, RTI uses a <a href="http://netty.io">Netty</a> based TCP server for ingesting protocol events. If you use the Spring auto configuration
    approach for registering the ProtocolAdapter implementation, you can then override the default TCP server that RTI uses. For example, if you are
    writing codec for some different protocol other than TCP, such as UDP, SCTP etc. then you must override the default TCP server that RTI uses.
    Here is how you may create your own UDP server using a combination of <a href="http://projects.spring.io/spring-integration/">Spring Integration</a>
    and <a href="http://projects.spring.io/spring-framework/">core Spring Framework</a>. The SDK compatible Spring Integration and Netty dependencies are
    also provided as part of the protocols-api-config-dependencies module. 
    
    <p>
    
    <pre class="code">
package foo.bar.autoconfig;
&#064;Configuration
&#064;EnableIntegration
public class FooBarProtocolAdapterAutoConfiguration {

    &#064;Bean(name = { "foobarProtocolAdapter" })
    public FooBarProtocolAdapter createProtocolAdapter() {
        return new FooBarProtocolAdapter();
    }

    &#064;Configuration
    &#064;ConditionalOnExpression("${rti.protocol.server:true}")
    static class FooBarUDPServerInfrastructure {

        &#064;Autowired
        FooBarProtocolAdapter foobarProtocolAdapter;

        &#064;Bean
        public MessageChannel output() {
            return new DirectChannel();
        }

        &#064;Value("${foobar.udp.port:29008}")
        private int port;

        &#064;Value("${foobar.worker.count:32}")
        private int workerCount;

        &#064;Bean(name = "packets")
        public MessageChannel packets() {
            return new DirectChannel();
        }

        &#064;Bean
        public TaskExecutor threadPoolTaskExecutor() {
            ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
            taskExecutor.setCorePoolSize(workerCount);
            return taskExecutor;
        }

        &#064;Bean
        public UnicastReceivingChannelAdapter udpInboundAdapter() {
            UnicastReceivingChannelAdapter unicastReceivingChannelAdapter = new UnicastReceivingChannelAdapter(port);
            unicastReceivingChannelAdapter.setOutputChannel(packets());
            unicastReceivingChannelAdapter.setReceiveBufferSize(2000);
            unicastReceivingChannelAdapter.setTaskExecutor(threadPoolTaskExecutor());
            return unicastReceivingChannelAdapter;
        }

        &#064;Bean
        public Transformer bytesToEventTransformer() {
            return new FooBarAdapterTransformer(foobarProtocolAdapter);
        }

        &#064;Bean
        &#064;org.springframework.integration.annotation.Transformer(inputChannel = "packets", outputChannel = "output")
        public Transformer bytesToEvent() {
            return new MethodInvokingTransformer(bytesToEventTransformer(), "transform");
        }
    }

}
            </pre>
<p>
    The gist of the above code fragment is that in addition to create the ProtocolAdapter, this also provides the necessary
    UDP server infrastructure for RTI. It creates a Unicast UDP server at port 29008 (can be overridden externally) and receives
    messages on this port using configured number of worker threads and pass them down to a Spring Integration channel named packets.
    It then gets transformed into
    <code>ProtocolEvent</code>s by
    <a href="http://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/MethodInvokingTransformer.html">MethodInvokingTransformer</a>.
    The code assumes that there is a transformer by the name FooBarAdapaterTransformer
    which uses the underlying ProtocolAdapter to transform the bytes into <code>ProtocolEvent</code>s.
    <p>

    <b>Two very important aspects of the above code:</b> You must wrap your inner server infrastructure bean with
    &#064;ConditionalOnExpression("${rti.protocol.server:true}"). This would give the RTI Ingester instruction <b>not</b> to
    create the default TCP server, but instead use the provided server. Another important thing is that if you provide your own
    server infrastructure, please make sure to provide a Spring Integration channel named <b>output</b> and make that as the
    endpoint component in your server flow. RTI Ingester relies on it to delegate events downstream.

    <p>

    <h1>Binary and Text based protocols</h1>
    By default RTI assumes that all protocols are binary based, but it supports text based protocols as well. In order
    to let RTI be aware that the protocol implemented is textual, the implementing protocol adapter must be annotated
    with <code>TextProtocol</code>. This is necessary because the default Netty TCP server will then
    switch over to a line based channel instead of the frame based channels used for binary data.
    <p>
    For binary protocols, the corresponding RTI Ingester TCP server uses the following default values. All of them can be
    overridden based on your specific needs. The text "foobar" has to be changed with your protocol name if you are overriding it.
    <p>
    <pre class="code">
foobar.maxFrameLength=8192
foobar.lengthFieldOffset=0
foobar.lengthFieldLength=4
foobar.lengthAdjustment=0
        </pre>
<p>
    Similarly, for text protocols, following is the default line length used, but can be overridden to other values.
<p>
    <pre class="code">
foobar.maxLineLength=8192
  </pre>
<p>
    Following properties are common to both binary and text protocols, and the TCP
    server uses these default values all of which can be overridden by the user.<p>

    <pre class="code">
foobar.tcp.host=127.0.0.1
foobar.selector.count=1
foobar.worker.count=32
foobar.worker.daemon=true
foobar.shutdown.timeout=5000
foobar.socket.backlog=100
foobar.socket.keepAlive=false
foobar.socket.timeout=20000
        </pre>
<p>

    <p>
        Following properties are available at the ingester level for various protocols.
        You may choose to override them.

    <pre class="code">
rti.ingester.foobar.batch.size=2048
rti.ingester.foobar.batch.timeout=4000
rti.ingester.foobar.batch.stats=true
rti.ingester.foobar.batch.dropDataAfterBufferFull=false
rti.ingester.foobar.batch.backlog=8192
rti.ingester.foobar.batch.threads=8
        </pre>

    </p>

    For the TCP server port, we encourage the users to provide RTI with a reasonable value. Although RTI will default to
    an available port, there are two reasons why we recommend the user to provide RTI the port. One is that the users know
    which ports are available or have preference on which ports to send the data, thus having full control
    over where they are spinning the protocols. Another more important reason is that, you reduce the non-deterministic
    nature of where you are sending the protocol data from one run of RTI to next. In order to override the tcp port, please
    provide a value as following:

    <pre class="code">
foobar.tcp.port=29009
</pre>

<h1>Contributing New Protocol Fields to RTI Data Dictionay</h1>

<p>
    Rtish allows you to find all the existing supported fields for various protocols in RTI Data Dictionary.
    In addition to these, you can also let RTI discover new fields that you may introduce through custom protocol adapter
    implementations.

    <pre class="code">
        &#064;ProtocolDetails(details={
            &#064;ProtocolDetail(name="foo", type=int.class, description = "this is foo"),
            &#064;ProtocolDetail(name="bar", type=String.class, description = "this is bar")
        })
    </pre>

    This annotation must be used in one of the 3 following places.
    <ol>
        <li>It can be annotated on the Spring auto configuration class where you configure to build the adapter</li>
        <li>Even if you are using the Spring auto config approach, you can still use this annotation on the ProtocolAdapter
        implementation itself as a class level annotation.</li>
        <li>If you are not using the spring option, then this annotation must be tagged on the ProtocolAdapter class itself.</li>
    </ol>

</p>


<p>

        For further API reference, more example code and developer documentation, see the RTI documentation.
    </p></div>
</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-files/index-1.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &copy; 2014 <a href="http://www.pivotal.io/">Pivotal</a>.</small></p>
</body>
</html>
